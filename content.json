{"meta":{"title":"Kevin's Blog","subtitle":"Stay Hungry, Stay Foolish","description":"个人博客","author":"Kevin","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2021-10-31T10:04:08.976Z","updated":"2021-06-04T01:09:22.725Z","comments":true,"path":"2021/10/31/hello-world/","link":"","permalink":"http://example.com/2021/10/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Learning notes","slug":"Learning-notes","date":"2021-08-07T23:54:29.000Z","updated":"2021-08-09T01:33:15.574Z","comments":true,"path":"2021/08/08/Learning-notes/","link":"","permalink":"http://example.com/2021/08/08/Learning-notes/","excerpt":"","text":"使用@property装饰器1234567891011class Student(object): @property #装饰器@property使getter方法转化为属性 def score(self): return self._score @score.setter #@property本身又创建了另一个装饰器@score.setter，负责把setter方法变成属性赋值 def score(self, value): if not isinstance(value, int): raise ValueError(&#x27;score must be an integer&#x27;) if value &lt; 0 or value &gt; 100 : raise ValueError(&#x27;score must between 0~100&#x27;) self._score = value 多重继承通过多重继承，一个子类就可以同时获得多个父类的所有功能。 12345678910111213141516171819202122232425class Animal(object): pass#大类class Mammal(Animal): passclass Bird(Animal): pass#各类动物class Dog(Mammal): passclass Bat(Mammal): passclass Parrot(Bird): pass#定义新类class Runnerable(object): def run(self): print(&#x27;Running&#x27;)class Flyable(object): def fly(&#x27;Flying&#x27;)#多重继承class Dog(Mammal, Runnable): passclass Bat(Mammal,Flyable): pass MixIn设计为了更好地看出继承关系，我们把 Runnable和 Flyable改为 RunnableMixIn和 FlyableMixIn。类似的，你还可以定义出肉食动物 CarnivorousMixIn和植食动物 HerbivoresMixIn，让某个动物同时拥有好几个 MixIn： 12class Dog(Mammal, RunnableMixIn, CarnivorousMixIn): pass MixIn 的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个 MixIn 的功能，而不是设计多层次的复杂的继承关系。 定制类__str__ &amp; __repr__123456789class Student(object): def __init__(self, name): self.name = name#__str__()方法返回用户看到的字符串 def __str__(self): return &#x27;Student object (name= %s)&#x27; % self.name#直接显示变量需要调用__repr__()方法，其为程序员调试使用 __repr__ = __str__ __iter__12345678910111213141516&#x27;&#x27;&#x27;如果一个类想被用于 for ... in 循环，类似 list 或 tuple 那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python 的 for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到 StopIteration 错误时退出循环。&#x27;&#x27;&#x27;class Fib(object): def __init__(self): self.a, self.b = 0, 1 #初始化计数器 def __iter__(self): return self #示例本身就是迭代对象，故返回自己 def __next__(self): self.a, self.b = self.b, self.a + self.b if self.a &gt; 1000 : #退出条件 raise StopIteration(): return self.a #返回下一个值 __getitem__123456789&#x27;&#x27;&#x27;__getitem__方法可以实现像list按下标取出元素&#x27;&#x27;&#x27;class Fib(object): def __getitem__(self, n): a, b = 1, 1 for x in range(n): a, b = b, a + b return a __getattr__123456789101112&#x27;&#x27;&#x27;当调用不存在的属性（attribute）或者函数时，Python 解释器会试图调用__getattr__(self, &#x27;score&#x27;)来尝试获得属性，这样，我们就有机会返回 score的值&#x27;&#x27;&#x27;class Student(object): def __init__(self): self.name = &#x27;Kevin&#x27; def __getattr__(self, attr): if attr == &#x27;score&#x27;: return 89 __call__1234567891011&#x27;&#x27;&#x27;任意类,只需定义一个__call__()方法,就可以直接对实例进行调用通过 callable()函数，我们就可以判断一个对象是否是“可调用”对象。&#x27;&#x27;&#x27;class Student(object): def __init__(self, name): self.name = name def __call__(self): print(&#x27;My name is %s.&#x27; % self.name) 枚举类12345678910111213&#x27;&#x27;&#x27;类似C++,Python 提供了 Enum 类来实现这个功能调用 Enum 的第一个参数是枚举的名称。第二个参数是枚举成员名称的来源。&#x27;&#x27;&#x27;from enum import EnumMonth = Enum(&#x27;Month&#x27;, (&#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;Mar&#x27;, &#x27;Apr&#x27;, &#x27;May&#x27;, &#x27;Jun&#x27;, &#x27;Jul&#x27;, &#x27;Aug&#x27;, &#x27;Sep&#x27;, &#x27;Oct&#x27;, &#x27;Nov&#x27;, &#x27;Dec&#x27;))for name, member in Month.__members__.items(): print(name, &#x27;=&gt;&#x27;, member, &#x27;,&#x27;, member.value) #value 属性则是自动赋给成员的 int 常量，默认从 1 开始计数 123456789101112131415&#x27;&#x27;&#x27;如果需要更精确地控制枚举类型，可以从 Enum 派生出自定义类&#x27;&#x27;&#x27;from enum import Enum, unique@unique # @unique 装饰器可以检查保证没有重复值class Weekday(Enum): Sun = 0 # Sun 的 value 被设定为 0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 访问枚举类型,既可以用成员名称引用枚举常量，又可以直接根据 value 的值获得枚举常量。 使用元类type()class type(object)class type(name, bases, dict) 传入一个参数时，返回 object 的类型。 返回值是一个 type 对象，通常与 object.__class__ 所返回的对象相同。 推荐使用 isinstance() 内置函数来检测对象的类型，因为它会考虑子类的情况。 传入三个参数时，返回一个新的 type 对象。 这在本质上是 class 语句的一种动态形式。 name 字符串即类名并且会成为 __name__ 属性；bases 元组列出基类并且会成为 __bases__ 属性；而 dict 字典为包含类主体定义的命名空间并且会被复制到一个标准字典成为 __dict__ 属性。 例如，下面两条语句会创建相同的 type 对象: 12345&gt;&gt;&gt; class X:... a = 1...&gt;&gt;&gt; X = type(&#x27;X&#x27;, (object,), dict(a=1)) metaclass除了使用 type()动态创建类以外，可以使用 metaclass控制类的行为。 metaclass，直译为元类，简单的解释就是： 当我们定义了类以后，就可以根据这个类创建出实例，所以： 先定义类，然后创建实例。 但是如果我们想创建出类呢？那就必须根据 metaclass 创建出类，所以：先定义 metaclass，然后创建类。 连接起来就是：先定义 metaclass，就可以创建类，最后创建实例。 所以，metaclass 允许你创建类或者修改类。换句话说，你可以把类看成是 metaclass 创建出来的“实例”。 一般来说，应该直接在类的定义中写上方法，但是，有些情况需要通过 metaclass来修改类的定义。例如 ORM——“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作 SQL 语句。","categories":[],"tags":[]}],"categories":[],"tags":[]}